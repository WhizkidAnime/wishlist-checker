# Системные Паттерны: Мой Вишлист

## Архитектурные решения

### 1. Централизованное состояние с Props Drilling
**Паттерн:** Основное состояние хранится в `App.tsx`, передается через props в дочерние компоненты.

**Обоснование:** 
- Простота и прозрачность потока данных
- Легкость отладки и понимания
- Избежание сложности state management библиотек для небольшого приложения

**Реализация:**
```typescript
// App.tsx - центральное место управления состоянием
function App() {
  const { user, isAuthenticated, loading } = useAuth();
  const { triggerSync } = useSupabaseSync(user?.id || null);
  
  return (
    <MainApp 
      triggerSync={triggerSync} 
      onAuthModalOpen={() => setIsAuthModalOpen(true)}
      onDataLoaded={handleDataLoaded}
    />
  );
}
```

### 2. Специализированные хуки
**Паттерн:** Каждый хук отвечает за конкретную область функциональности.

**Хуки в проекте:**
- `useAuth` - управление аутентификацией
- `useWishlist` - управление списком товаров
- `useCategories` - управление категориями
- `useTheme` - управление темами
- `useSupabaseSync` - синхронизация с облаком
- `useBulkActions` - массовые операции
- `useImportExport` - импорт/экспорт данных

**Преимущества:**
- Разделение ответственности
- Переиспользование логики
- Легкость тестирования
- Чистота компонентов

### 3. Graceful Degradation
**Паттерн:** Приложение работает полноценно без внешних зависимостей, но получает расширенные возможности при их наличии.

**Уровни функциональности:**
1. **Базовый уровень** - работа без интернета и авторизации
2. **Расширенный уровень** - синхронизация при наличии аккаунта
3. **Полный уровень** - все возможности при стабильном соединении

**Реализация:**
```typescript
// Проверка доступности Supabase
const isSupabaseAvailable = () => {
  return !!(supabase && process.env.REACT_APP_SUPABASE_URL);
};

// Условная синхронизация
if (isSupabaseAvailable() && isAuthenticated) {
  await syncWithSupabase();
} else {
  // Работаем локально
  saveToLocalStorage();
}
```

## Паттерны управления данными

### 1. Тройное хранение
**Паттерн:** Разделение данных по типам и местам хранения.

**Структура хранения:**
- **Товары** - Memory State (при авторизации) / Supabase (облако)
- **Категории** - localStorage + Supabase (при авторизации)
- **Настройки темы** - localStorage + Supabase (при авторизации)

**Логика:**
```typescript
// Локальные настройки - всегда в localStorage
localStorage.setItem('wishlist-theme-mode', themeMode);

// Данные пользователя - в зависимости от авторизации
if (isAuthenticated) {
  await supabase.from('wishlist_items').insert(item);
} else {
  // Храним в памяти компонента
  setWishlist(prev => [...prev, item]);
}
```

### 2. Блокировка синхронизации
**Паттерн:** Предотвращение конфликтов при одновременных операциях.

**Реализация:**
```typescript
// syncBlockManager.ts
class SyncBlockManager {
  private blocks = new Set<string>();
  
  block(reason: string) {
    this.blocks.add(reason);
  }
  
  unblock(reason: string) {
    this.blocks.delete(reason);
  }
  
  isBlocked(): boolean {
    return this.blocks.size > 0;
  }
}
```

**Использование:**
- Блокировка при редактировании товара
- Блокировка при перетаскивании
- Блокировка при массовых операциях

### 3. Оптимистичные обновления
**Паттерн:** Сначала обновляем UI, затем синхронизируем с сервером.

**Процесс:**
1. Пользователь выполняет действие
2. UI мгновенно обновляется
3. Запрос отправляется на сервер
4. При ошибке - откат изменений

## Паттерны интерфейса

### 1. Адаптивное позиционирование
**Паттерн:** Элементы интерфейса адаптируются к размеру экрана.

**Примеры:**
- **Переключатель тем:** рядом с заголовком на мобильных, fixed в углу на десктопе
- **Панель управления:** вертикальная на мобильных, горизонтальная на десктопе
- **Модальные окна:** полноэкранные на мобильных, центрированные на десктопе

**Реализация:**
```typescript
const isMobile = useIsMobile();

return (
  <div className={`theme-toggle ${
    isMobile 
      ? 'relative ml-4' 
      : 'fixed top-4 right-4'
  }`}>
```

### 2. Условный рендеринг состояний
**Паттерн:** Активное использование тернарных операторов для отображения разных состояний.

**Применение:**
- Загрузка vs готовые данные
- Авторизованный vs неавторизованный пользователь
- Пустой список vs список с товарами
- Редактирование vs просмотр

**Пример:**
```typescript
{isLoading ? (
  <LoadingSpinner />
) : wishlist.length === 0 ? (
  <EmptyState />
) : (
  <WishlistItems items={wishlist} />
)}
```

### 3. Прогрессивное раскрытие
**Паттерн:** Сложные функции скрыты до тех пор, пока они не понадобятся.

**Примеры:**
- Дополнительные поля при создании товара
- Массовые операции появляются при выборе товаров
- Расширенные настройки в профиле пользователя

## Паттерны производительности

### 1. Мемоизация вычислений
**Паттерн:** Кэширование результатов дорогих вычислений.

**Использование:**
```typescript
const filteredAndSortedWishlist = useMemo(() => {
  return getFilteredAndSortedItems(wishlist);
}, [wishlist, searchQuery, sortBy]);

const totalUnbought = useMemo(() => {
  return wishlist
    .filter(item => !item.isBought)
    .reduce((sum, item) => sum + item.price, 0);
}, [wishlist]);
```

### 2. Дебаунсинг пользовательского ввода
**Паттерн:** Задержка обработки частых событий.

**Применение:**
- Поиск по списку товаров
- Автосохранение при редактировании
- Синхронизация изменений

### 3. Ленивая загрузка компонентов
**Паттерн:** Загрузка компонентов по требованию.

**Реализация:**
```typescript
const AuthModal = lazy(() => import('./AuthModal'));
const CalculatorPopup = lazy(() => import('./CalculatorPopup'));
```

## Паттерны безопасности

### 1. Row Level Security (RLS)
**Паттерн:** Данные пользователя доступны только ему самому.

**Настройка в Supabase:**
```sql
CREATE POLICY "Users can only see their own data" ON wishlist_items
FOR ALL USING (auth.uid() = user_id);
```

### 2. Валидация данных
**Паттерн:** Проверка данных на клиенте и сервере.

**Уровни валидации:**
- TypeScript типы на этапе разработки
- Валидация форм перед отправкой
- Валидация в базе данных (constraints)

### 3. Обработка ошибок
**Паттерн:** Graceful handling всех возможных ошибок.

**Стратегия:**
```typescript
try {
  await supabaseOperation();
} catch (error) {
  console.error('Supabase error:', error);
  // Fallback на локальное хранение
  saveToLocalStorage();
  // Уведомление пользователя
  showErrorNotification();
}
```

## Паттерны тестирования

### 1. Модульное тестирование хуков
**Паттерн:** Тестирование бизнес-логики отдельно от UI.

**Структура:**
```
src/hooks/__tests__/
├── useTheme.test.ts
├── useWishlist.test.ts
└── useCategories.test.ts
```

### 2. Мокирование внешних зависимостей
**Паттерн:** Изоляция тестов от внешних сервисов.

**Применение:**
- Мокирование Supabase API
- Мокирование localStorage
- Мокирование системных функций (matchMedia)

## Эволюция паттернов

### Усвоенные принципы
1. **Простота превыше сложности** - выбор простых решений над сложными
2. **Постепенное усложнение** - добавление сложности только при необходимости
3. **Консистентность** - единообразие в архитектурных решениях
4. **Тестируемость** - архитектура должна легко тестироваться
5. **Расширяемость** - возможность добавления новых функций без переписывания 